html { position: relative; padding:0; }
html, body { height: 100%; }
.view3d { width: 100%; height:100%; top: 0; left: 0; margin: 0; padding:0; /*overflow: hidden;*/ position: fixed; }

.scene {
    position: absolute;
    perspective: 100vmin;
    opacity: 0.9;
    top: 50%;
    left: 50%;
    width: 100vmin;
    height: 100vmin;
    transform: translate3d(-50%, -50%, 0) scale(1);
    font-size: x-large;
}

/*
.scene .rest { background: black; }
.scene .scene  .rest { background: white; }
.rest:hover { background: red; }
:target > .scene > .rest { display: none }
*/

#no .scene > .room { animation: 8s turntable infinite; animation-timing-function: ease; }

.scene .scene {
    transform: translate3d(-50%, -50%, 0) scale(0.9);
    /*overflow: hidden; bug in firefox which scrolls the element when the target changes, instead use clip-path */
    clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
    border: thin solid blue;
}

.scene .test2 .scene { transform: translate3d(-50%, -50%, 0) scale(0.25); }

.three-d {
    position: absolute;
    transition: transform ease 20s;
    transform-style: preserve-3d;
    top: 50%;
    left: 50%;
}

.object {
    border: thin solid red;
    background: pink;
}

:root {
    --origin: translate3d(-50%, -50%, -50vmin);
    --origin-: translate3d(50%, 50%, 50vmin);
}

:root {
    --test: translate3d(-49vmin, 0vmin, 0vmin) rotateY(90deg) scale(0.6);
    --test-: rotateY(-90deg) translate3d(49vmin, 0vmin, 0vmin);
    --test-hover: translate3d(0vmin,0,50vmin) rotateY(0deg) scale(1);
}

.test { width: 90vmin; height: 90vmin; transform: var(--origin)  var(--test); }
.room:target-within > .test { transform: var(--origin) var(--test-hover); }
.room.target-within > .test { transform: var(--origin) var(--test-hover); }

:root {
    --test2: translate3d(49vmin, 0vmin, 0vmin) rotateY(-90deg);
    --test2-: rotateY(90deg) translate3d(-49vmin, 0vmin, 0vmin);
    --test2-hover: translate3d(0,0,50vmin) rotateY(0deg);
}

.test { --scale: 0.6; }
.test2 { --scale: 1; }

:root {
    --opacity: 1;
}

.test2 { width: 50vmin; height: 25vmin; transform: var(--origin) var(--test2); opacity: var(--opacity); }
.room:target-within > .test2 { transform: var(--origin) var(--test2-hover) scale(2); }
.room.target-within > .test2 { transform: var(--origin) var(--test2-hover) scale(2); }

.hover { z-index: 20; }
.hover:target-within { z-index: 30; }
.hover.target-within { z-index: 30; }

.hover .hover { z-index: 40; }
.hover:target-within .hover:target-within { z-index: 50; }
.hover.target-within .hover.target-within { z-index: 50; }

.wall-l { opacity: 0.3; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(-50vmin, 0, 0) rotateY(90deg); }
.wall-r { opacity: 0.3; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(50vmin, 0, 0)  rotateY(90deg); }
.wall-u { opacity: 0.3; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(0, -50vmin, 0) rotateX(90deg); }
.wall-d { opacity: 0.7; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(0, 50vmin, 0)  rotateX(90deg); }
.wall-b { opacity: 0.3; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(0, 0, -50vmin); }
.wall-f { opacity: 0.1; background: var(--rainbow); width: 100vmin; height: 100vmin; transform: var(--origin) translate3d(0, 0, 50vmin);
          pointer-events: none; }

.wall { pointer-events: none; }

@keyframes turntable {
    0% { transform: translate3d(-50%, -50%, 0) scale(1) rotateZ(0deg) rotateY(-7deg) rotateX(-7deg); }
    25% { transform: translate3d(-50%, -50%, 0) scale(1) rotateZ(-3deg) rotateY(-3deg) rotateX(7deg); }
    50% { transform: translate3d(-50%, -50%, 0) scale(1) rotateZ(5deg) rotateY(7deg) rotateX(-7deg); }
    75% { transform: translate3d(-50%, -50%, 0) scale(1) rotateZ(-3deg) rotateY(3deg) rotateX(7deg); }
    100% { transform: translate3d(-50%, -50%, 0) scale(1) rotateZ(0deg)  rotateY(-7deg) rotateX(-7deg); }
}

.room { transform: translate3d(0,0,0) rotate(0); }
.room-test:target-within ~ .room { transform: var(--origin) var(--test-hover) var(--test-) var(--origin-); }
.room-test.target-within ~ .room { transform: var(--origin) var(--test-hover) var(--test-) var(--origin-); }
.room-test:target-within ~ .room .test2 { opacity: 0; left: 9999vmin; transition: translate 20s, opacity 1s, left step-end 1s; }
.room-test.target-within ~ .room .test2 { opacity: 0; left: 9999vmin; transition: translate 20s, opacity 1s, left step-end 1s; }
.room .test2 { transition: transform ease 20s, opacity 1s linear 1s, left step-end 1s; }
.room-test2:target-within ~ .room { transform: var(--origin) var(--test2-hover) var(--test2-) var(--origin-); }
.room-test2.target-within ~ .room { transform: var(--origin) var(--test2-hover) var(--test2-) var(--origin-); }

:root {
    --rainbow-saturation: 80%;
    --rainbow-lightness: 40%;
    --rainbow: linear-gradient(
        45deg,
        hsl(0,   var(--rainbow-saturation), var(--rainbow-lightness)) 0%,
        hsl(36,  var(--rainbow-saturation), var(--rainbow-lightness)) 10%,
        hsl(72,  var(--rainbow-saturation), var(--rainbow-lightness)) 20%,
        hsl(108, var(--rainbow-saturation), var(--rainbow-lightness)) 30%,
        hsl(144, var(--rainbow-saturation), var(--rainbow-lightness)) 40%,
        hsl(180, var(--rainbow-saturation), var(--rainbow-lightness)) 50%,
        hsl(216, var(--rainbow-saturation), var(--rainbow-lightness)) 60%,
        hsl(252, var(--rainbow-saturation), var(--rainbow-lightness)) 70%,
        hsl(288, var(--rainbow-saturation), var(--rainbow-lightness)) 80%,
        hsl(324, var(--rainbow-saturation), var(--rainbow-lightness)) 90%,
        hsl(360, var(--rainbow-saturation), var(--rainbow-lightness)) 100%)
}

/* text in the center of a square filling its parent, semi-transparent white background with an opaque white band below the text. */
.go {
    background: rgba(255, 255, 255, 0.6); color: black; text-decoration: none; outline: thin solid white;
    /*mask-image: linear-gradient(rgba(0, 0, 0, 0.6) calc(50% - 0.75em), black calc(50% - 0.75em), black calc(50% + 0.75em), rgba(0, 0, 0, 0.6) calc(50% + 0.75em));*/
    display: flex; align-items: center; justify-content: center; font-size: calc(130% / var(--scale)); transform-style: preserve-3d;
    position: absolute; top: 0; left: 0; min-width: max-content; width: 100%; min-height: 1.5em; height: 100%; z-index: 100;
    /*transition: background 2s, width 1s step-start, height 1s step-start; */
    transition: var(--transition-to-forward);
}
/* semi-transparent on hover */
.go:hover { background: rgba(255, 255, 255, 0.1); }

/* White band behind text */
:not(.target-within) > .go::before,
:target > .go::before {
    background: white; color: white; opacity: 1;
    position: fixed; z-index: -1; left: 0; top: calc(50% - 0.75em); width: 100%; min-width: auto; height: auto; line-height: 1.5em;
    color: transparent; /* hide the "← back to …" text */ /* todo: width 0 */

    transition: var(--transition-to-forward);
}

/* white band semi-transparent on hover */
:not(.target-within) > .go:hover::before { background: rgba(255, 255, 255, 0.6); }

/* link is displayed in top left corner when the link goes out of the current room */
.target-within:not(:target) > .go {
    border: thin solid black; background: white; color: black; outline: thin solid rgba(255,255,255,0);
    width: 0%; height: 0%; font-size: 1rem;
    /*transition: background 2s, width 1s step-start, height 1s step-start;*/
    transition: var(--transition-to-back);
}

.go {
    --transition-to-forward: background 2s linear, color 2s linear, border 2s linear, outline 2s linear, opacity 2s linear, width 1s step-start, height 1s step-start;
    --transition-to-current: background 2s linear, color 2s linear, border 2s linear, outline 2s linear, opacity 2s linear, width 2s linear 1s,   height 2s step-end;
    --transition-to-back:    background 2s linear, color 2s linear, border 2s linear, outline 2s linear, opacity 2s linear, width 1s step-start, height 1s step-start;
}

/* ← back to … when the link goes out of the current room. To be able to animate it, the content is always there, and the colour changes. */
.target-within:not(:target) > .go::before { color: black; transition: var(--transition-to-back); }
.go::before { content: '← back to '; }

/* debug */
:target > .go::before { transition: var(--transition-to-current); }
:target > .go::before { background: purple; }

/* disable the link when it points to the current room */
/*:target > .go { background: rgba(255,0,0,0.1); color: rgba(0,0,0,0.1); border: thin solid rgba(0,0,255,1); outline-color: rgba(0,255,0,0.1); pointer-events: none; transition: var(--transition-to-current); }*/
:target > .go { background: transparent; color: transparent; border: thin solid transparent; outline-color: transparent; pointer-events: none; transition: var(--transition-to-current); }

/* animate colourful arrow and disable it when the target is in a nested room */
:target-within > .go::after { --distance: calc(0 - var(--width)) !important; pointer-events: none; transition: background 6s var(--ease-out-bounce), transform 10s var(--ease-out-bounce), left 10s step-end, opacity 10s step-end; }
.target-within > .go::after { --distance: calc(0 - var(--width)) !important; pointer-events: none; transition: background 6s var(--ease-out-bounce), transform 10s var(--ease-out-bounce), left 10s step-end, opacity 10s step-end; }

/* animate position and gradient of colourful arrow on hover */
.go:hover::after { --distance: calc(var(--min-distance) + var(--shift)); background-position-x: 25%; /* leave 25% for bounce easing */ }

/* draw colourful arrow */
.go::after {
    --width: 10; /* vmin */
    --shift: 8; /* vmin */
    --min-distance: 10; /* vmin */
    --distance: var(--min-distance); /* vmin, animated */
    --border: calc(var(--min-distance) + var(--shift)); /* vmin */
    --z: calc(((var(--width) - var(--border)) / 2 + var(--distance)) * 1vmin);
    --arrow-width-ratio: calc(var(--width) / (var(--width) + var(--border)));
    position: absolute; content: ''; top:50%; left: 50%; width: calc(var(--width) * 1vmin); height: calc(10vmin / var(--scale));
    --ease-out-bounce: cubic-bezier(0.3, 1.8, 0.9, 0.9);
    transition: background 6s var(--ease-out-bounce), transform 10s var(--ease-out-bounce), left 10s step-start;
    transform: translate3d(-50%, -50%, var(--z)) rotateY(45deg);
    --arrow-thickness: 20%;
    --arrowhead-position: 60%;
    --arrowhead-angle: 51.34deg;
    --bg: rgba(214, 93, 184, 0.5);
    border-right: calc(var(--border) * 1vmin) solid transparent;
    background-image: linear-gradient(90deg, rgba(102, 231, 231, 0.856) 25%, rgba(255,255,255,0.8) 50%, rgba(214, 93, 184, 0.7) 75%);
    background-size: 400%;
    background-position-x: 75%; /* leave 25% for bounce easing */
    background-repeat: no-repeat;
    --vertical-triangle: calc(var(--arrowhead-position) * var(--arrow-width-ratio));
    --arrow-top: calc(50% - var(--arrow-thickness));
    --arrow-bottom: calc(50% + var(--arrow-thickness));
    --mask-image: conic-gradient(from calc(-90deg - var(--arrowhead-angle)) at calc(100% * var(--arrow-width-ratio)) center, black 0deg, black calc(var(--arrowhead-angle)*2), transparent calc(var(--arrowhead-angle)*2)),
                  linear-gradient(90deg, transparent var(--vertical-triangle), black var(--vertical-triangle)),
                  linear-gradient(0deg, transparent var(--arrow-top), black var(--arrow-top), black var(--arrow-bottom), transparent var(--arrow-bottom));
    mask-image: var(--mask-image);
    -webkit-mask-image: var(--mask-image);
    mask-composite: intersect, add;
    -webkit-mask-composite: destination-in, source-over;
}


.comment.target-within:target > .go::before {
    /*transition: background 0.6s linear, transform linear 1s, top 1s step-end, left 1s step-end, opacity 0.6s linear;*/
    content: '← back (:target)' attr(href);
    background: red; color: black; border: thin solid black;
    top: 0; 
    opacity: 0;
    transition: /*all step-end 10s,*/
        background 5s linear 5s,
        color 5s linear 5s,
        border 5s linear 5s,
        opacity 1s linear 1s,
        top 5s linear 5s,
        width 5s linear 5s,
        min-height step-end 5s; /* delay needed to keep the band the same height as it disappears */;

    min-width: max-content; width: 0%;
    min-height: 0;
    z-index: 1;
    /*height: auto;position: fixed; padding: 0;mask-image: none; right: unset; width: auto; left: -9999vmin; */
}
.comment.target-within:not(:target) > .go::before {
    /*transition: background 6s, transform 10s linear 10s, left 10s step-end, opacity 10s;*/
    background: /*green*/ transparent; color: black; border: /*thin solid black*/ none;
    top: 0;
    /*position: fixed; width: auto;*/ height: auto;
    content: '← back to ';
    opacity: 0.8;
    
    transition: /*all step-end 10s,*/
        background 5s linear 5s,
        color 5s linear 5s,
        border 5s linear 5s,
        opacity 1s linear 1s,
        top 5s linear 5s,
        width 5s linear 5s,
        height 5s linear 5s;

    min-width: max-content; width: 0%;
    min-height: 0;
    z-index: 1;
    /*left: -9999vmin;right: auto; padding: 0;mask-image: none;*/
    display: inline-block;
    position: relative;
    font-size: 1rem;
}

.rest { display: none; }
.hover-anim .rest { position: absolute; top: 0; left: 0; bottom: 0; right: 0; }
.scene:target-within:not(:target) > .room.room-test:not(:target-within) { transform: var(--origin) var(--test2-hover) var(--test2-) var(--origin-); }
.scene.target-within:not(:target) > .room.room-test:not(.target-within) { transform: var(--origin) var(--test2-hover) var(--test2-) var(--origin-); }
.scene:target-within:not(:target) > .room:not(:target-within) .test { opacity: 0; left: 999px; transition: translate 20s, opacity 10s, left step-end 10s; }
.scene.target-within:not(:target) > .room:not(.target-within) .test { opacity: 0; left: 999px; transition: translate 20s, opacity 10s, left step-end 10s; }

.room .test { transition: transform ease 20s, opacity 10s linear 10s, left step-end 10s; }

.object:target-within:before { opacity: 1; }
.object.target-within:before { opacity: 1; }
.object:before {
    content: normal;/*"← back"; for hover only*/
    border: thin solid brown;
    background: white;
    z-index: 999;
    position: absolute;
    transform: translate3d(0, -100%, 0);
    opacity: 0;
    transition: opacity 10s linear 10s;
    pointer-events: none;
}